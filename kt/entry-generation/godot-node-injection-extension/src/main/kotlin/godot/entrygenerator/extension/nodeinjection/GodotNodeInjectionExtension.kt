package godot.entrygenerator.extension.nodeinjection

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.MemberName.Companion.member
import godot.entrygenerator.extension.DescriptorContainer
import godot.entrygenerator.extension.EntryGeneratorExtension
import godot.entrygenerator.model.ClassWithMembers
import godot.entrygenerator.extension.nodeinjection.annotation.InjectNode
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import org.jetbrains.kotlin.types.typeUtil.supertypes

class GodotNodeInjectionExtension : EntryGeneratorExtension() {
    private lateinit var propertiesToInject: Map<DeclarationDescriptor, Set<PropertyDescriptor>>

    override fun provideExtensionName(): String {
        return "Godot Node Injection Extension"
    }

    override fun provideFullyQualifiedAnnotations(): Set<String> {
        return setOf(InjectNode::class.java.canonicalName)
    }

    override fun performSanityChecks(extensionDescriptorContainer: DescriptorContainer, messageCollector: MessageCollector) {
        extensionDescriptorContainer.properties.forEach {
            if (it.type.getJetTypeFqName(false) != "godot.Node" && !it.type.supertypes().any { supertype -> supertype.getJetTypeFqName(false) == "godot.Node" }) {
                throw IllegalStateException("The annotation \"InjectNode\" can only be used on properties which type derives from \"Node\"")
            }
        }
    }

    override fun beforeEntryGenerationHook(registrationDescriptorContainer: DescriptorContainer, extensionDescriptorContainer: DescriptorContainer, bindingContext: BindingContext, messageCollector: MessageCollector) {
        propertiesToInject = extensionDescriptorContainer.properties.groupBy { it.containingDeclaration }.map { it.key to it.value.toSet() }.toMap()
    }

    override fun writeToEntryFileRoot(entryFileSpec: FileSpec.Builder, descriptorContainer: Set<ClassWithMembers>, messageCollector: MessageCollector) {
        if (propertiesToInject.isNotEmpty()) {
            descriptorContainer.forEach { classWithMember ->
                val containingClassFqName = classWithMember.classDescriptor.fqNameSafe.asString()
                classWithMember.properties.forEach { property ->
                    if (property.annotations.mapNotNull { it.fqName?.asString() }.contains(InjectNode::class.java.canonicalName)) {
                        entryFileSpec
                            .addProperty(
                                PropertySpec
                                    .builder("${property.name.asString()}NodePath", ClassName("godot.core", "NodePath"))
                                    .addKdoc("Generated by ${provideExtensionName()}")
                                    .addModifiers(KModifier.PRIVATE)
                                    .mutable(true)
                                    .receiver(ClassName(containingClassFqName.substringBeforeLast("."), containingClassFqName.substringAfterLast(".")))
                                    .getter(
                                        FunSpec
                                            .getterBuilder()
                                            .addStatement("return·%M", ClassName("godot", "GodotNodeInjectionExtension").member("${property.containingDeclaration.name.asString()}_${property.name.asString()}_nodePathBacking"))
                                            .build()
                                    )
                                    .setter(
                                        FunSpec
                                            .setterBuilder()
                                            .addParameter(ParameterSpec("value", ClassName("godot.core", "NodePath")))
                                            .addStatement("%M·=·value", ClassName("godot", "GodotNodeInjectionExtension").member("${property.containingDeclaration.name.asString()}_${property.name.asString()}_nodePathBacking"))
                                            .build()
                                    )
                                    .build()
                            )
                    }
                }
            }

            val injectionExtensionObjectBuilder = TypeSpec
                .objectBuilder("GodotNodeInjectionExtension")
                .addKdoc("Generated by ${provideExtensionName()}")

            descriptorContainer.forEach { classWithMember ->
                classWithMember.properties.forEach { property ->
                    if (property.annotations.mapNotNull { it.fqName?.asString() }.contains(InjectNode::class.java.canonicalName)) {
                        injectionExtensionObjectBuilder
                            .addProperty(
                                PropertySpec
                                    .builder("${property.containingDeclaration.name.asString()}_${property.name.asString()}_nodePathBacking", ClassName("godot.core", "NodePath"))
                                    .mutable(true)
                                    .initializer("%T()", ClassName("godot.core", "NodePath"))
                                    .build()
                            )
                    }
                }
            }

            entryFileSpec.addType(
                injectionExtensionObjectBuilder.build()
            )
        }
    }

    override fun registersElementsForClass(classWithMembers: ClassWithMembers, messageCollector: MessageCollector): Boolean {
        return propertiesToInject[classWithMembers.classDescriptor]?.isNotEmpty() ?: false
    }

    override fun registerProperties(
        registeredProperties: List<PropertyDescriptor>,
        propertiesAnnotatedForThisExtension: List<PropertyDescriptor>,
        registerClassControlFlow: FunSpec.Builder,
        className: ClassName,
        bindingContext: BindingContext,
        messageCollector: MessageCollector
    ) {
        propertiesAnnotatedForThisExtension.forEach { propertyDescriptor ->
            registerClassControlFlow.addStatement(
                "property(%L,·%T,·%T,·%S,·%T,·%S,·%T())",
                className.member("${propertyDescriptor.name.asString()}NodePath").reference(),
                ClassName("godot.core.VariantType", "NODE_PATH"),
                ClassName("godot.core.VariantType", "NODE_PATH"),
                "godot.core.NodePath",
                ClassName("godot.core.PropertyHint", "NONE"),
                "",
                ClassName("godot.core", "NodePath")
            )
        }
    }

    override fun overridesFunction(functionDescriptor: FunctionDescriptor, messageCollector: MessageCollector): Boolean {
        return functionDescriptor.name.asString() == "_ready" && propertiesToInject.keys.contains(functionDescriptor.containingDeclaration)
    }

    override fun beforeFunctionBody(beforeOnReadyFunSpec: FunSpec.Builder, functionDescriptor: FunctionDescriptor, messageCollector: MessageCollector) {
        propertiesToInject[functionDescriptor.containingDeclaration]?.let { propertyDescriptors ->
            propertyDescriptors.forEach { propertyDescriptor ->
                val returnTypeFqName = propertyDescriptor.type.getJetTypeFqName(false)
                beforeOnReadyFunSpec.addStatement(
                    "instance.${propertyDescriptor.name.asString()}·=·instance.getNode(instance.${propertyDescriptor.name.asString()}NodePath)·as·%T${if (propertyDescriptor.type.isMarkedNullable) "?" else ""}",
                    ClassName(returnTypeFqName.substringBeforeLast("."), returnTypeFqName.substringAfterLast("."))
                )
            }
        }
    }
}
