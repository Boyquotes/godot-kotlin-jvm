package godot.entrygenerator.extension.nodeinjection

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.MemberName.Companion.member
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import godot.entrygenerator.extension.DescriptorContainer
import godot.entrygenerator.extension.EntryGeneratorExtension
import godot.entrygenerator.model.ClassWithMembers
import godot.entrygenerator.extension.nodeinjection.annotation.InjectNode
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe
import org.jetbrains.kotlin.types.typeUtil.supertypes

class GodotNodeInjectionExtension : EntryGeneratorExtension() {
    private lateinit var propertiesToInject: Map<DeclarationDescriptor, Set<PropertyDescriptor>>

    override fun provideExtensionName(): String {
        return "Godot Node Injection Extension"
    }

    override fun provideFullyQualifiedAnnotations(): Set<String> {
        return setOf(InjectNode::class.java.canonicalName)
    }

    override fun performSanityChecks(extensionDescriptorContainer: DescriptorContainer, messageCollector: MessageCollector) {
        extensionDescriptorContainer.properties.forEach {
            if (it.type.getJetTypeFqName(false) != "godot.Node" && !it.type.supertypes().any { supertype -> supertype.getJetTypeFqName(false) == "godot.Node" }) {
                throw IllegalStateException("The annotation \"InjectNode\" can only be used on properties which type derives from \"Node\"")
            }
        }
    }

    override fun beforeEntryGenerationHook(registrationDescriptorContainer: DescriptorContainer, extensionDescriptorContainer: DescriptorContainer, bindingContext: BindingContext, messageCollector: MessageCollector) {
        propertiesToInject = extensionDescriptorContainer.properties.groupBy { it.containingDeclaration }.map { it.key to it.value.toSet() }.toMap()
    }

    override fun writeToEntryFileRoot(entryFileSpec: FileSpec.Builder, descriptorContainer: Set<ClassWithMembers>, messageCollector: MessageCollector) {
        if (propertiesToInject.isNotEmpty()) {
            descriptorContainer.forEach { classWithMember ->
                val containingClassFqName = classWithMember.classDescriptor.fqNameSafe.asString()
                classWithMember.properties.forEach { property ->
                    if (property.annotations.mapNotNull { it.fqName?.asString() }.contains(InjectNode::class.java.canonicalName)) {
                        entryFileSpec
                            .addProperty(
                                PropertySpec
                                    .builder("${property.name.asString()}NodePath", ClassName("godot.core", "NodePath"))
                                    .addKdoc("Generated by ${provideExtensionName()}")
                                    .addModifiers(KModifier.PRIVATE)
                                    .mutable(true)
                                    .receiver(ClassName(containingClassFqName.substringBeforeLast("."), containingClassFqName.substringAfterLast(".")))
                                    .getter(
                                        FunSpec
                                            .getterBuilder()
                                            //GodotNodeInjectionExtension.injectionInstanceToNodePaths[this] ?: NodePath()
                                            .addStatement(
                                                "return·%M[this]·?:·%T()",
                                                ClassName("godot", "GodotNodeInjectionExtension")
                                                    .member("injectionInstanceToNodePaths"),
                                                ClassName("godot.core", "NodePath")
                                            )
                                            .build()
                                    )
                                    .setter(
                                        FunSpec
                                            .setterBuilder()
                                            .addParameter(ParameterSpec("value", ClassName("godot.core", "NodePath")))
                                            //GodotNodeInjectionExtension.injectionInstanceToNodePaths[this] = value
                                            .addStatement(
                                                "%M[this]·=·value",
                                                ClassName("godot", "GodotNodeInjectionExtension")
                                                    .member("injectionInstanceToNodePaths")
                                            )
                                            .build()
                                    )
                                    .build()
                            )
                    }
                }
            }

            entryFileSpec.addType(
                TypeSpec
                    .objectBuilder("GodotNodeInjectionExtension")
                    .addModifiers(KModifier.PRIVATE)
                    .addKdoc("Generated by ${provideExtensionName()}")
                    //val injectionInstanceToNodePaths: MutableMap<KtObject, NodePath> = mutableMapOf()
                    .addProperty(
                        PropertySpec
                            .builder(
                                "injectionInstanceToNodePaths",
                                ClassName("kotlin.collections", "MutableMap")
                                    .parameterizedBy(
                                        ClassName("godot.core", "KtObject"),
                                        ClassName("godot.core", "NodePath")
                                    )
                            )
                            .initializer("mutableMapOf()")
                            .build()
                    )
                    .build()
            )
        }
    }

    override fun registersElementsForClass(classWithMembers: ClassWithMembers, messageCollector: MessageCollector): Boolean {
        return propertiesToInject[classWithMembers.classDescriptor]?.isNotEmpty() ?: false
    }

    override fun registerProperties(
        registeredProperties: List<PropertyDescriptor>,
        propertiesAnnotatedForThisExtension: List<PropertyDescriptor>,
        registerClassControlFlow: FunSpec.Builder,
        className: ClassName,
        bindingContext: BindingContext,
        messageCollector: MessageCollector
    ) {
        //KtObject.subscribeToOnDestroy<Invocation> { GodotNodeInjectionExtension.injectionInstanceToNodePaths.remove(it) }
        registerClassControlFlow.addStatement(
            "%M<%T>·{·%M.remove(it)·}",
            ClassName("godot.core.KtObject", "Companion")
                .member("subscribeToOnDestroy"),
            className,
            ClassName("godot", "GodotNodeInjectionExtension")
                .member("injectionInstanceToNodePaths")
        )

        propertiesAnnotatedForThisExtension.forEach { propertyDescriptor ->
            registerClassControlFlow.addStatement(
                "property(%L,·%T,·%T,·%S,·%T,·%S,·%T())",
                className.member("${propertyDescriptor.name.asString()}NodePath").reference(),
                ClassName("godot.core.VariantType", "NODE_PATH"),
                ClassName("godot.core.VariantType", "NODE_PATH"),
                "godot.core.NodePath",
                ClassName("godot.core.PropertyHint", "NONE"),
                "",
                ClassName("godot.core", "NodePath")
            )
        }
    }

    override fun overridesFunction(functionDescriptor: FunctionDescriptor, messageCollector: MessageCollector): Boolean {
        return functionDescriptor.name.asString() == "_ready" && propertiesToInject.keys.contains(functionDescriptor.containingDeclaration)
    }

    override fun beforeFunctionBody(beforeOnReadyFunSpec: FunSpec.Builder, functionDescriptor: FunctionDescriptor, messageCollector: MessageCollector) {
        propertiesToInject[functionDescriptor.containingDeclaration]?.let { propertyDescriptors ->
            propertyDescriptors.forEach { propertyDescriptor ->
                val returnTypeFqName = propertyDescriptor.type.getJetTypeFqName(false)
                beforeOnReadyFunSpec.addStatement(
                    "instance.${propertyDescriptor.name.asString()}·=·instance.getNode(instance.${propertyDescriptor.name.asString()}NodePath)·as·%T${if (propertyDescriptor.type.isMarkedNullable) "?" else ""}",
                    ClassName(returnTypeFqName.substringBeforeLast("."), returnTypeFqName.substringAfterLast("."))
                )
            }
        }
    }
}
